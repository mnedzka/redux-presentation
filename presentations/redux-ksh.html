<section>
  <img src="assets/redux/redux-logo.png" class="clean-img full-width" />
  <h3>Redux Introduction</h3>
  <small>(27.03.2019)</small>
</section>

<section>
  <section>
    <h2>The state challenge in Javascript</h2>
  </section>
  <section>
    <h2>MVC</h2>
    <p class="fragment fade-in">
      Invented in 70's. Used in backend in Java, PHP, ASP.NET, C#, ROR, Django. On frontend side in
      Backbone or AngularJS
      <img src="assets/redux/mvc-diagram.png" class="fragment fade-in clean-img full-width" />
    </p>
  </section>
  <section>
    <h2>What's the problem?</h2>
    <p class="fragment fade-in">
      Play well in small client applications but has problems when app grows because of two way data
      binding which cause hard to track changes in application state.
    </p>
    <p class="fragment fade-in">
      The problem is in two way data binding MVC is that they have many to many dependency between
      models and views.
    </p>
    <p class="fragment fade-in">
      A model can update a view which can update a model which can update another model and there
      can be a infinite loop of cascading updates.
    </p>
  </section>
  <section>
    <p>
      Facebook faces the problem while developing chat system, view1 manipulates model1 and model1
      updates the view2 like their system has circular dependency thats why they came up with
      solution flux.
    </p>
  </section>
  <section>
    <p class="citation">
      In a talk Jing Chen ( Creator of Flux ) said - "There is just an explosion of command flows,
      and it is hard to tell if there is any infinite loop that might be causing a cascading
      effect."
    </p>
  </section>
  <section>
    <h2>Unidirectional data flow</h2>
    <p class="fragment fade-in">
      In unidirectional data flow action updates stores which updates views. So if there is a error
      it would be easy to track which action caused it. Unidirectional data flow is more
      predictable.
    </p>
  </section>
  <section>
    <img src="assets/redux/mvc-problem.jpg" class="fragment fade-in clean-img full-width" />
  </section>
</section>

<section>
  <h2>FLUX</h2>
  <img src="assets/redux/flux.png" class=" clean-img full-width" />
  <p class="fragment fade-in">
    "Flux is more of a pattern than a framework or toll like Redux"
  </p>
  <p class="fragment fade-in">
    A year after releasing React, Facebook announced the "Flux Architecture"
  </p>
  <p class="fragment fade-in citation">
    "We found that two-way data bindings led to cascading updates, where changing one object led to
    another object changing, which could also trigger more updates. As applications grew, these
    cascading updates made it very difficult to predict what would change as the result of one user
    interaction. When updates can only change data within a single round, the system as a whole
    becomes more predictable."
  </p>
</section>

<section>
  <h2>What Is Redux?</h2>
  <section>
    <p class="fragment fade-in">
      Developer experience (DX)
    </p>
    <img src="assets/redux/dan_abramov.jpg" class="fragment fade-in clean-img full-width" />
  </section>
</section>

<section>
  <section>
    <h2>What Is Redux?</h2>
  </section>
  <section>
    <p class="fade-in">A popular state management library</p>
    <p class="fragment fade-in">Created by Dan Abramov and Andrew Clark</p>
    <p class="fragment fade-in">Inspired by Facebook Flux and Elm</p>
    <p class="fragment fade-in">Models the application state as a single JavaScript Object</p>
    <p class="fragment fade-in">Often used with React but it does not depend on React</p>
  </section>
  <section>
    <h2 class="fade-in">
      Predictable
    </h2>
    <p class="fragment fade-in">
      Redux attempts to make state mutations predictable by imposing certain restrictions on how and
      when updates can happen.
    </p>
    <p class="fragment fade-in">
      These restrictions are reflected in the three principles of Redux:
    </p>
  </section>
  <section>
    <h2 class="fade-in">
      Single source of truth
    </h2>
    <p class="fragment fade-in">
      The state of your whole application is stored as a tree of plain objects and arrays within a
      single store. (How much you put in the store is up to you - not all data needs to live there.)
    </p>
    <p class="fragment fade-in">
      This one-store approach of Redux is one of the primary differences between it and Flux's
      multiple store approach.
    </p>
  </section>
  <section>
    <h2 class="fade-in">
      State is read-only
    </h2>
    <p class="fragment fade-in">
      State updates are caused by dispatching an action, which is a plain object describing what
      happened. The rest of the app is not allowed to modify the state tree directly. No setters.
    </p>
  </section>
  <section>
    <h2 class="fade-in">
      Changes through pure functions
    </h2>
    <p class="fragment fade-in">
      All state updates are performed by pure functions called reducers, which are:
    </p>
    <p class="fragment fade-in">
      (state, action) => newState
    </p>
  </section>
  <section>
    <h2>Centralized</h2>
    <p class="fragment fade-in">
      Having a single store and single state tree enables many powerful techniques:
    </p>
    <p class="fragment fade-in">
      logging of all updates, API handling, undo/redo, state persistence, "time-travel debugging",
      error reports with full snapshots of app state, and more.
    </p>
  </section>
</section>

<section>
  <h2>Quiz time</h2>
  <p class="fragment fade-in">
    Please visit: link
  </p>
</section>

<section>
  <section>
    <h2>Do we even need Redux in React?</h2>
  </section>

  <section>
    <p class="fade-in">
      Besides "predictable state updates" and "centralized state handling" here's a few more reasons
    </p>
  </section>
  <section>
    <p class="fade-in">
      "Time-travel debugging" allows developers to step back and forth in the history of dispatched
      actions, see the state and UI at each point in time, and even alter the history by canceling
      actions.
    </p>
  </section>
  <section>
    <p class="fade-in">
      Lifting state up
    </p>
  </section>
  <section>
    <p class="fade-in">
      Hot module reloading
    </p>
  </section>
  <section>
    <p class="fade-in">
      Easiness in testing
    </p>
  </section>
</section>

<section>
  <h2>Functional programming</h2>
  <section>
    <img src="assets/redux/passByValue-vs-passByReference.gif" class="clean-img full-width" />
  </section>
</section>

<section>
  <img src="assets/redux/dan_abramov.jpg" class="clean-img full-width" />
</section>
<section>
  <img src="assets/redux/ReactDataFlow.gif" class="clean-img full-width" />
</section>
<section>
  <img src="assets/redux/doing-what-dan-said.jpg" class="clean-img full-width" />
</section>

<section>
  <section>
    <h2>Vanilla Redux</h2>
    <p class="fragment fade-in"></p>
  </section>

  <section>
    <h2>Goals</h2>
    <p class="fragment fade-in">Describe actions and reducers in redux</p>
    <p class="fragment fade-in">Describe methods on the redux store</p>
    <p class="fragment fade-in">Define basic flow</p>
  </section>

  <section>
    <h2>Action</h2>
    <p class="fragment fade-in">
      A plain JavaScript object that must have a key called type and a string value
    </p>
    <img src="assets/redux/action.svg" class="fragment fade-in clean-img full-width" />

    <section>
      <p>The action can have any number of additional keys</p>
      <img src="assets/redux/action2.svg" class="fragment fade-in clean-img full-width" />
      <img src="assets/redux/action3.svg" class="fragment fade-in clean-img full-width" />
    </section>
  </section>
  <section>
    <section>
      <h2>Reducer</h2>
      <p class="fragment fade-in">
        A function that accepts the state and an action and returns a new state (entire state
        object)
      </p>
      <img src="assets/redux/action3.svg" class="fragment fade-in clean-img full-width" />
    </section>
  </section>

  <h2>Creating A Store</h2>
  <p class="fragment fade-in">
    A plain JavaScript object that must have a key called type and a string value
  </p>
</section>

<section>
  <h2>Using Redux with React</h2>
  <p class="fragment fade-in">
    connect:
  </p>

  <p class="fragment fade-in">
    Function mapStateToProps: called every time the store state changes. It receives the entire
    store state, and should return an object full of data. Each field in the returned object becomes
    a prop for the wrapped component.
  </p>
  <p class="fragment fade-in">
    Function mapDispatchToProps: called once on component creation. It receives the dispatch method,
    and should return an object full of functions that use dispatch.
  </p>
</section>

<section>
  <h2>Redux Middleware</h2>
  <p class="fragment fade-in">
    A Redux store can be configured to use middleware. Middleware provides the capability to run
    code after an action is dispatched, but before it reaches the reducer
  </p>
  <p class="fragment fade-in">
    Middlewares form a pipeline that wraps around the dispatch function. Each middleware in the
    chain can pass actions onward, restart the dispatch pipeline, and access the store state.
  </p>
</section>
<section>
  <img src="assets/redux/with-and-without-redux.png" class="clean-img full-width" />
</section>

<section>
  <h2>Quiz time</h2>
  <p class="fragment fade-in">
    Please visit: link
  </p>
</section>
